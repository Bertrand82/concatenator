

 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ClassPair.javaxxxx

package atom.tools.very.simple.comparator.checker;

public class ClassPair {

    public Class classIn;

    public Class classOut;

    boolean isAlreadyProcessed = false;

    public ClassPair() {
    }

    public ClassPair(final Class pClassIn, final Class pClassOut) {
        super();
        classIn = pClassIn;
        classOut = pClassOut;
    }

    /**
     * @return Attribut {@link #isAlreadyProcessed}
     */
    public boolean isAlreadyProcessed() {
        return isAlreadyProcessed;
    }

    /**
     * @param pIsAlreadyProcessed Valeur à affecter à l'attribut {@link #isAlreadyProcessed}
     */
    public void setAlreadyProcessed(final boolean pIsAlreadyProcessed) {
        isAlreadyProcessed = pIsAlreadyProcessed;
    }

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx GeneratorCheckerStringForgottenClass.javaxxxx

package atom.tools.very.simple.comparator.checker;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import javax.lang.model.element.Modifier;

import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;

import atom.msa.fr.sante.prestationsennature.facturepn.services.v1.RapportFactory;
import atom.msa.fr.sante.prestationsennature.facturepn.services.v1.RapportManager;
import bg.very.simple.mapper.JavaPoetWriter;

public class GeneratorCheckerStringForgottenClass {

    private static String packageName = "atom.generated.comparator";

    List<GeneratorCheckerStringForgottenMethod> listComparatorGenerator = new ArrayList<>();

    private final JavaPoetWriter javaPoetWritter;

    private final File dirOutput = new File("GENERATED_COMPARATOR");

    private final ClassPair classPair;

    public GeneratorCheckerStringForgottenClass(final Class<?> clazzOut, final Class<?> clazzIn)
            throws ClassNotFoundException {
        super();
        dirOutput.mkdirs();
        final ClassPair cp = new ClassPair(clazzIn, clazzOut);
        classPair = cp;
        processClass(cp);

        javaPoetWritter = new JavaPoetWriter(dirOutput);
        javaPoetWritter.write(getJavaFileChecker());
        System.err.println("Done  dirOutput.exists :" + dirOutput.exists());
    }

    private void processClass(final ClassPair cPair) throws ClassNotFoundException {
        final GeneratorCheckerStringForgottenMethod cg = new GeneratorCheckerStringForgottenMethod(cPair);
        listComparatorGenerator.add(cg);
        for (final ClassPair cp : cg.getListClassPair()) {
            if (!cp.isAlreadyProcessed()) {
                processClass(cp);
            }
        }

    }

    /**
     * @param pCp
     */
    private void processGeneratorJavaFile() {
        javaPoetWritter.write(getJavaFileChecker());

    }

    public JavaFile getJavaFileChecker() {

        final TypeSpec.Builder classBuilder = TypeSpec.classBuilder(getClassMapperName()).addModifiers(Modifier.PUBLIC);

        final MethodSpec constructor0 = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC)
                .addStatement("this($T.getRapportManager())", RapportFactory.class).build();

        final MethodSpec constructor1 = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC)
                .addParameter(RapportManager.class, "rapportManager")
                .addStatement("this.rapportManager = rapportManager", RapportFactory.class).build();
        String comment = "Cette Class permet de s'assurer que lors des opérations de mappage, certains champs que l'on n'a pas pu mapper de String vers des enum ont bien recupéré leurs valeurs originelles à la fin du traitement \n";
        comment += " Les classes vérifiées sont les suivantes : \n";
        comment += "In : \t" + classPair.classIn.getName() + "\n";
        comment += "Out: \t" + classPair.classOut.getName() + "\n";
        classBuilder.addJavadoc(comment);

        classBuilder.addMethod(constructor0);
        classBuilder.addMethod(constructor1);
        classBuilder.addField(FieldSpec.builder(RapportManager.class, "rapportManager", Modifier.PRIVATE).build());

        for (final GeneratorCheckerStringForgottenMethod cg : listComparatorGenerator) {
            classBuilder.addMethod(cg.getMethodCompare());
        }

        final TypeSpec customClassMapper = classBuilder.build();
        final JavaFile.Builder javaFileBuilder = JavaFile.builder(packageName, customClassMapper).indent("    ");

        javaFileBuilder.addFileComment("Generated by " + this.getClass().getName());
        final JavaFile javaFile = javaFileBuilder.build();
        return javaFile;
    }

    private String getClassMapperName() {
        return "CheckerStringForgotten";
    }

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx GeneratorCheckerStringForgottenMethod.javaxxxx

package atom.tools.very.simple.comparator.checker;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.lang.model.element.Modifier;

import com.squareup.javapoet.MethodSpec;

import fr.msa.atom.sante.prestationsennature.facturepn.types.v1.DateNaissanceAtom;

public class GeneratorCheckerStringForgottenMethod {

    private final List<ClassPair> listClassPair = new ArrayList<ClassPair>();

    private final List<Field> listList = new ArrayList<Field>();

    private final List<Field> listListString = new ArrayList<Field>();

    private final List<Field> listString = new ArrayList<>();

    private final List<Field> listField = new ArrayList<>();

    private final Class clazzOut;

    private final Class clazzIn;

    public GeneratorCheckerStringForgottenMethod(final ClassPair cPair) {
        cPair.setAlreadyProcessed(true);

        clazzIn = cPair.classIn;
        clazzOut = cPair.classOut;
        for (final Field fieldOut : clazzOut.getDeclaredFields()) {
            final Field fieldIn = getFieldFromClass(clazzIn, fieldOut.getName());
            if (fieldOut.getType().isEnum()) {

            } else if (fieldOut.getType().isPrimitive()) {

            } else if (fieldOut.getType().equals(String.class)) {
                if (getterExistForField(clazzOut, fieldOut)) {
                    listString.add(fieldOut);
                }
            } else if (fieldOut.getType().equals(Double.class)) {

            } else if (fieldOut.getType().equals(Integer.class)) {

            } else if (fieldOut.getType().equals(Boolean.class)) {

            } else if (fieldOut.getType().equals(Date.class)) {

            } else if (fieldOut.getType().equals(ClassLoader.class)) {

            } else if (fieldOut.getType().equals(Class.class)) {

            } else if (fieldOut.getType().getPackage() == null) {

            } else if ((fieldOut.getType().getPackage().getName() + "").startsWith("sun.reflect.")) {

            } else if (fieldOut.getType().getPackage().getName().startsWith("sun.")) {

            } else if (fieldOut.getType().isArray()) {

            } else if (fieldOut.getType().equals(DateNaissanceAtom.class)) {

            } else if (fieldOut.getType().equals(List.class)) {

                final Class<?> cOut = getGenericTypeFromList(fieldOut);
                final Class<?> cIn = getGenericTypeFromList(fieldIn);
                if (cOut.equals(String.class)) {
                    listListString.add(fieldOut);
                } else {
                    listList.add(fieldOut);
                    final ClassPair cp = new ClassPair(cIn, cOut);
                    listClassPair.add(cp);
                }

            } else {
                if (getterExistForField(clazzOut, fieldOut)) {
                    final ClassPair cp = new ClassPair(fieldIn.getType(), fieldOut.getType());
                    listClassPair.add(cp);
                    listField.add(fieldOut);
                }
            }
        }
    }

    private Field getFieldFromClass(final Class clazz, final String fieldName) {
        for (final Field f : clazz.getDeclaredFields()) {
            if (f.getName().equals(fieldName)) {
                return f;
            }
        }
        return null;
    }

    private Class<?> getGenericTypeFromList(final Field field) {
        final ParameterizedType listType = (ParameterizedType) field.getGenericType();
        final Class<?> c = (Class<?>) listType.getActualTypeArguments()[0];
        return c;

    }

    private boolean getterExistForField(final Class pClazz, final Field field) {
        final String getter = getGetter(field).replace("()", "");
        for (final Method m : clazzOut.getMethods()) {
            if (m.getName().equals(getter)) {
                return true;
            }
        }
        return false;
    }

    public MethodSpec getMethodCompare() {
        final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(prefixMethod + clazzOut.getSimpleName())
                .addParameter(clazzOut, "out").addParameter(clazzIn, "in").addModifiers(Modifier.PUBLIC);
        methodBuilder.beginControlFlow("if (out == null)");
        methodBuilder.addStatement("return");
        methodBuilder.endControlFlow();
        methodBuilder.beginControlFlow("if (in == null)");
        methodBuilder.addStatement("return");
        methodBuilder.endControlFlow();

        methodBuilder.addStatement("//Nombre de  String :  " + listString.size());
        for (final Field fString : listString) {
            final String name = fString.getName();
            methodBuilder.addStatement("// String " + name);
            methodBuilder.beginControlFlow(
                    "if ((out." + getGetter(fString) + "== null) &&  (in." + getGetter(fString) + "!= null))");
            methodBuilder.addStatement("String value =in." + getGetter(fString));
            methodBuilder.beginControlFlow("if ( this.rapportManager.isNonMapped(value))");
            methodBuilder.addStatement("out." + getSetter(fString) + "(value)");
            methodBuilder.endControlFlow();
            methodBuilder.endControlFlow();
        }

        for (final Field field : listField) {
            methodBuilder.addStatement("//F  " + field.getName() + "  " + field.getType().getSimpleName());
            methodBuilder.addStatement(prefixMethod + field.getType().getSimpleName() + "(out." + getGetter(field)
                    + ", in." + getGetter(field) + ")");

        }

        for (final Field field : listList) {
            methodBuilder.addStatement("//L  " + field.getName() + "  list " + getGenericTypeFromList(field));
            final Class<?> c = getGenericTypeFromList(field);
            final String getter = getGetter(field);
            methodBuilder.beginControlFlow("for(int i=0; i<in." + getter + ".size();i++)");
            methodBuilder.addStatement(
                    prefixMethod + c.getSimpleName() + "( out." + getter + ".get(i), in." + getter + ".get(i))");
            methodBuilder.endControlFlow();

        }
        for (final Field field : listListString) {
            methodBuilder.addStatement(
                    "//LS  " + field.getName() + "  list " + getGenericTypeFromList(field) + " No Implemented");

        }

        return methodBuilder.build();

    }

    /**
     * @return Attribut {@link #listClassPair}
     */
    public List<ClassPair> getListClassPair() {
        return listClassPair;
    }

    /**
     * @return Attribut {@link #clazz}
     */
    public Class getClazz() {
        return clazzOut;
    }

    /**
     * @param pField1
     * @return
     */
    private static String getGetter(final Field field) {
        final String name = capitalizeFirstLetter(field.getName());
        final String methodName = "get" + name + "()";
        return methodName;
    }

    /**
     * @param pField1
     * @return
     */
    private static String getSetter(final Field field) {
        final String name = capitalizeFirstLetter(field.getName());
        final String methodName = "set" + name;
        return methodName;
    }

    /**
     * @param pName
     * @return
     */
    private static String capitalizeFirstLetter(final String str) {
        final String s = str.substring(0, 1).toUpperCase() + str.substring(1);
        return s;
    }

    private static String prefixMethod = "checkStringForgottenIn_";

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx MainGeneratorChecker.javaxxxx

package atom.tools.very.simple.comparator.checker;

public class MainGeneratorChecker {

    /**
     * Generation du code permettant de verifier qu'aucun String n'a été oublié.
     * La classe générée est incorporée dans le projet bm1atom-tarif-ws
     *
     * @param s
     * @throws Exception
     */
    public static void main(final String[] s) throws Exception {
        final Class clazzIn = fr.msa.atom.sante.prestationsennature.facturepn.objets.factureatom.v1.InfoFactureCalculee.class;
        final Class clazzOut = fr.msa.atom.sante.prestationsennature.facturepn.objets.v1.InfoFactureCalculee.class;
        System.out.println("MainComparator start ");
        final GeneratorCheckerStringForgottenClass generator = new GeneratorCheckerStringForgottenClass(clazzOut,
                clazzIn);
    }
}

 wwwwwwwwwwwwww bg wwwwwwwwwww


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ClassFinder.javaxxxx

package bg;




import java.io.File;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;

/**
 * @author c82bgui
 *
 */
public class ClassFinder {

    private static final char PKG_SEPARATOR = '.';

    private static final char DIR_SEPARATOR = '/';

    private static final String CLASS_FILE_SUFFIX = ".class";

    private static final String BAD_PACKAGE_ERROR = "Unable to get resources from path '%s'. Are you sure the package '%s' exists?";

    public static List<Class<?>> find(final String scannedPackage) {
        final String scannedPath = scannedPackage.replace(PKG_SEPARATOR, DIR_SEPARATOR);
        final URL scannedUrl = Thread.currentThread().getContextClassLoader().getResource(scannedPath);
        if (scannedUrl == null) {
            throw new IllegalArgumentException(String.format(BAD_PACKAGE_ERROR, scannedPath, scannedPackage));
        }
        final File scannedDir = new File(scannedUrl.getFile());
        final List<Class<?>> classes = new ArrayList<Class<?>>();
        for (final File file : scannedDir.listFiles()) {
            classes.addAll(find(file, scannedPackage));
        }
        return classes;
    }

    private static List<Class<?>> find(final File file, final String scannedPackage) {
        final List<Class<?>> classes = new ArrayList<Class<?>>();
        final String resource = scannedPackage + PKG_SEPARATOR + file.getName();
        if (file.isDirectory()) {
            for (final File child : file.listFiles()) {
                classes.addAll(find(child, resource));
            }
        } else if (resource.endsWith(CLASS_FILE_SUFFIX)) {
            final int endIndex = resource.length() - CLASS_FILE_SUFFIX.length();
            final String className = resource.substring(0, endIndex);
            try {
                classes.add(Class.forName(className));
            } catch (final ClassNotFoundException ignore) {
            }
        }
        return classes;
    }

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ClassPair.javaxxxx

/**
 *
 */
package bg;

/**
 * @author c82bgui
 *
 */
public class ClassPair {

    Class c1;

    Class c2;

    /**
     * @param pC1
     * @param pC2
     */
    public ClassPair(final Class pC1, final Class pC2) {
        c1 = pC1;
        c2 = pC2;
    }

    /**
     * @return Attribut {@link #c1}
     */
    public Class getC1() {
        return c1;
    }

    /**
     * @param pC1 Valeur à affecter à l'attribut {@link #c1}
     */
    public void setC1(final Class pC1) {
        c1 = pC1;
    }

    /**
     * @return Attribut {@link #c2}
     */
    public Class getC2() {
        return c2;
    }

    /**
     * @param pC2 Valeur à affecter à l'attribut {@link #c2}
     */
    public void setC2(final Class pC2) {
        c2 = pC2;
    }

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx JavaPoetWriter.javaxxxx

package bg;




import java.io.File;
import java.io.IOException;

import com.squareup.javapoet.JavaFile;

/**
 * @author c82bgui
 *
 */
public class JavaPoetWriter {

    private final File dir;

    public JavaPoetWriter(File dir) {
    this.dir = dir;
        dir.mkdirs();
    }

    /**
     * @param pJavafile
     */
    public void write(final JavaFile javafile) {
        try {

            javafile.writeTo(dir);
           
        } catch (final IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

public File getDir() {
return dir;
}



}

 wwwwwwwwwwwwww justification wwwwwwwwwww


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx MainHelperJustification.javaxxxx

/**
 *
 */
package bg.justification;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;

import fr.atom.sante.prestationnature.gestionfactures.domain.facture.Justification;

/**
 * @author c82bgui
 *
 */
public class MainHelperJustification {

    final static List<Class> listClassesEnum = new ArrayList();

    public static void main(final String[] s) {
        final Class clazzJustification = Justification.class;
        System.out.println("\n\npublic class ElementJustificationKeys {\n\n");
        for (final Field field : clazzJustification.getDeclaredFields()) {

            if (field.getName().equals("serialVersionUID")) {
            } else {
                String comment = "Type :" + field.getType().getSimpleName();
                if (field.getType().isEnum()) {

                    comment += " isEnum :" + enumValue(field.getType());
                }
                System.out.println("");
                System.out.println("/* " + comment + " */");
                System.out.println(
                        "    public static final  String KEY_" + field.getName() + " = \"" + field.getName() + "\";");
            }
        }

        displayEnums(listClassesEnum);
        System.out.println("}");
    }

    /**
     * @param pType
     * @return
     */
    private static String enumValue(final Class<?> clazz) {
        String s = "";
        if (!listClassesEnum.contains(clazz)) {
            listClassesEnum.add(clazz);
        }

        for (final Field f : clazz.getDeclaredFields()) {
            if (f.getName().equals("ENUM$VALUES")) {

            } else {
                s += f.getName() + "; ";
            }
        }
        return s;

    }

    /**
     * @param pListclassesenum
     */
    private static void displayEnums(final List<Class> pListclassesenum) {
        for (final Class clazz : pListclassesenum) {
            displayClassEnum(clazz);
        }

    }

    /**
     * @param pClazz
     */
    private static void displayClassEnum(final Class clazz) {
        System.out.println("\n\nstatic class " + clazz.getSimpleName() + "{");
        for (final Field f : clazz.getDeclaredFields()) {
            if (f.getName().equals("ENUM$VALUES")) {

            } else {
                final String s = "public static final String KEY_" + f.getName() + " = \"" + f.getName() + "\"; ";
                System.out.println(s);
            }
        }
        System.out.println("}");
    }
}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx MainConcatene.javaxxxx

/**
 *
 */
package bg;

import java.io.File;
import java.nio.file.Files;

/**
 * @author c82bgui
 *
 */
public class MainConcatene {

    static String fileNames = "";

    static int i = 0;

    /**
     * @param args
     */
    public static void main(final String[] args) {
        final File dir = new File("src/main/java");
        System.out.println("dir " + dir.exists() + "  " + dir.getAbsolutePath());
        final String s = getConcatenate(dir);
        System.out.println(s);
        System.out.println(fileNames);

    }

    /**
     * @param pDir
     * @return
     */
    private static String getConcatenate(final File pDir) {
        String s = "\n wwwwwwwwwwwwww " + pDir.getName() + " wwwwwwwwwww\n";
        for (final File child : pDir.listFiles()) {
            if (child.isDirectory()) {
                s += getConcatenate(child);
            } else {
                s += "\n\n xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx " + child.getName() + "xxxx\n\n";
                s += getFile(child);
                fileNames += i++ + " " + pDir.getName() + "  " + child.getName() + "\n";
            }
        }
        return s;
    }

    /**
     * @param pChild
     * @return
     */
    private static String getFile(final File file) {
        try {
            final byte[] fileBytes = Files.readAllBytes(file.toPath());
            return new String(fileBytes);
        } catch (final Exception e) {
            return "Exception " + e.getMessage() + " : " + file.getName();
        }
    }

}

 wwwwwwwwwwwwww mapper wwwwwwwwwww


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ClassMapperGenerator.javaxxxx

package bg.mapper;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import javax.lang.model.element.Modifier;

import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;

import atom.msa.fr.sante.prestationsennature.facturepn.services.v1.RapportFactory;
import atom.msa.fr.sante.prestationsennature.facturepn.services.v1.RapportManager;
import bg.very.simple.mapper.JavaPoetWriter;

public class ClassMapperGenerator {

    private final String packageName = "bg.mapper";

    private final List<ClassPair> listPairInitiale;

    private final List<GeneratorMapperMethod> listGeneratorMapperMethod = new ArrayList<GeneratorMapperMethod>();

    private final File dirOutput = new File("GENERATED_COMPARATOR_MAPPER");

    private final JavaPoetWriter javaPoetWritter = new JavaPoetWriter(dirOutput);

    public ClassMapperGenerator(final List<ClassPair> pListPair) {
        listPairInitiale = pListPair;
        dirOutput.mkdirs();
        for (final ClassPair cp : listPairInitiale) {
            processClass(cp);
        }

        javaPoetWritter.write(getJavaFileMapper());

        System.err.println("Done  dirOutput.exists :" + dirOutput.exists());
    }

    private void processClass(final ClassPair pCp) {
    }

    public JavaFile getJavaFileMapper() {

        final TypeSpec.Builder classBuilder = TypeSpec.classBuilder(getClassMapperName()).addModifiers(Modifier.PUBLIC);

        final MethodSpec constructor0 = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC)
                .addStatement("this($T.getRapportManager())", RapportFactory.class).build();

        final MethodSpec constructor1 = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC)
                .addParameter(RapportManager.class, "rapportManager")
                .addStatement("this.rapportManager = rapportManager", RapportFactory.class).build();
        String comment = "Cette Class permet de s'assurer que lors des opérations de mappage, certains champs que l'on n'a pas pu mapper de String vers des enum ont bien recupéré leurs valeurs originelles à la fin du traitement \n";
        comment += " Les classes vérifiées sont les suivantes : \n";
        for (final ClassPair cp : listPairInitiale) {
            comment += " --------- ";
            comment += "1 : \t" + cp.c1.getName() + "\n";
            comment += "2: \t" + cp.c2.getName() + "\n";
        }
        classBuilder.addJavadoc(comment);
        classBuilder.addMethod(constructor0);
        classBuilder.addMethod(constructor1);
        classBuilder.addField(FieldSpec.builder(RapportManager.class, "rapportManager", Modifier.PRIVATE).build());

        for (final GeneratorMapperMethod cg : listGeneratorMapperMethod) {
            classBuilder.addMethod(cg.getMethodMapper1());
            classBuilder.addMethod(cg.getMethodMapper2());
        }

        final TypeSpec customClassMapper = classBuilder.build();
        final JavaFile.Builder javaFileBuilder = JavaFile.builder(packageName, customClassMapper).indent("    ");

        javaFileBuilder.addFileComment("Generated by " + this.getClass().getName());
        final JavaFile javaFile = javaFileBuilder.build();
        return javaFile;
    }

    private String getClassMapperName() {
        return null;
    }

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ClassPair.javaxxxx

/**
 *
 */
package bg.mapper;

/**
 * @author c82bgui
 *
 */
public class ClassPair {

    public final Class c1;

    public final Class c2;

    /**
     * @param pC1
     * @param pC2
     */
    public ClassPair(final Class pC1, final Class pC2) {
        super();
        c1 = pC1;
        c2 = pC2;
    }

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx GeneratorMapperMethod.javaxxxx

package bg.mapper;

import com.squareup.javapoet.MethodSpec;

public class GeneratorMapperMethod {

    public MethodSpec getMethodMapper1() {
        return null;
    }

    public MethodSpec getMethodMapper2() {
        return null;
    }

}

 wwwwwwwwwwwwww helper wwwwwwwwwww


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx MainListClassFromPackage.javaxxxx

/**
 *
 */
package bg.mapper.helper;

import java.util.List;

import bg.util.UtilPackage;

/**
 * @author c82bgui
 *
 */
public class MainListClassFromPackage {

    public static void main(final String[] s) {
        final String packageName = "atom.msa.fr.sante.prestationsennature.facturepn.enumcustommappers.v1";
        final List<Class> listClasses = UtilPackage.getClassesFromPackage(packageName);
        System.out.println("\n\n");
        for (final Class clazz : listClasses) {
            System.out.println("import " + clazz.getName() + " ;");
        }
        System.out.println("\n\n");
        int i = 0;
        for (final Class clazz : listClasses) {
            final String name = clazz.getSimpleName();
            System.out.println("" + name + "  " + name.toLowerCase() + "  = new " + name + "() " + ";");

        }
        for (final Class clazz : listClasses) {
            final String name = clazz.getSimpleName();
            System.out.println(name.toLowerCase() + ".map(\"Azerty" + i++ + "\");");
        }
    }
}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx MainGeneratorMapper.javaxxxx

package bg.mapper;

import java.util.ArrayList;
import java.util.List;

public class MainGeneratorMapper {

    public static void main(final String[] args) {
        final Class clazz1 = fr.msa.atom.sante.prestationsennature.facturepn.objets.factureatom.v1.InfoFactureCalculee.class;
        final Class clazz2 = fr.msa.atom.sante.prestationsennature.facturepn.objets.v1.InfoFactureCalculee.class;
        final ClassPair cp = new ClassPair(clazz1, clazz2);
        final List<ClassPair> listPair = new ArrayList<ClassPair>();
        final ClassMapperGenerator mapperGenerator = new ClassMapperGenerator(listPair);
    }

}

 wwwwwwwwwwwwww poet wwwwwwwwwww


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx PropertiesClasses.javaxxxx

/**
 *
 */
package bg;

import java.util.Properties;

/**
 * @author c82bgui
 *
 */
public class PropertiesClasses {

    public static Properties pClasses = new Properties();
    static {
        pClasses.setProperty("fr.msa.atom.sante.prestationsennature.facturepn.objets.individusanteatom.v1.Assureur",
                "fr.atom.referentiel.assurance.domain.assureur.Assureur");
        pClasses.setProperty(
                "fr.msa.atom.sante.prestationsennature.facturepn.objets.individusanteatom.v1.SoinsPlanifies",
                "fr.atom.sante.relationsassure.contratassurance.domain.contratassurance.SoinsPlanifies");
    }

    static Class getClassesPair(final String className) {
        try {
            final String name = pClasses.getProperty(className);
            if (name == null) {
                return null;
            }
            return PropertiesClasses.class.getClassLoader().loadClass(name);
        } catch (final ClassNotFoundException e) {
            return null;
        }

    }
}

 wwwwwwwwwwwwww util wwwwwwwwwww


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx MainGetClassesFromPackage.javaxxxx

package bg.util;

import java.util.List;

public class MainGetClassesFromPackage {

    public static void main(final String[] args) {
        traceClasses("bg");
        traceClasses("fr.xebia");
    }

    private static void traceClasses(final String packageName) {
        System.out.println("Package name " + packageName);
        final List<Class> listClasses = UtilPackage.getClassesFromPackage(packageName);
        for (final Class clazz : listClasses) {
            System.out.println(clazz.getName());
        }
        System.out.println("Package name " + packageName + "  list : " + listClasses.size());
    }

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx UtilJar.javaxxxx

/**
 *
 */
package bg.util;

import java.io.File;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

/**
 * @author c82bgui
 *         Obtenir toutes les classes d'un package
 */
public class UtilJar {

    public static void main(final String[] a) throws Exception {
        final List<Class> listClasses = getClassesFromPackage("com.squareup.javapoet");
    }

    public static List<Class> getClassesFromPackage(final String packageName) {

        final List<Class> listClasses = new ArrayList<>();

        System.err.println("UtilJar getSubClasses " + packageName);

        final String javaClassPaths[] = System.getProperty("java.class.path").split(";");
        for (final String s : javaClassPaths) {
            if (s.endsWith(".jar")) {
                listClasses.addAll(processJarFile(s.trim(), packageName));
            }
        }
        return listClasses;
    }

    /**
     * @param pS
     * @param pPackageName
     */
    private static List<Class> processJarFile(final String jarName, final String packageName) {
        final File file = new File(jarName);
        try {
            final List<String> listClassesName = new ArrayList<>();
            final JarFile jarFile = new JarFile(file);

            final Enumeration<JarEntry> enu = jarFile.entries();
            while (enu.hasMoreElements()) {
                final JarEntry jarEntry = enu.nextElement();
                final String name = jarEntry.getName().replaceAll("/", ".");
                if (name.startsWith(packageName)) {
                    if (!name.contains("$") && (name.endsWith(".class"))) {
                        final String nameCanonique = name.replace(".class", "");

                        listClassesName.add(nameCanonique);
                    }
                }

            }

            jarFile.close();
            return toClasses(listClassesName);
        } catch (final Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * @param pListClassesName
     * @return
     */
    private static List<Class> toClasses(final List<String> listClassesName) throws Exception {

        final List<Class> listClasses = new ArrayList<>();
        for (final String className : listClassesName) {
            final Class clazz = UtilJar.class.getClassLoader().loadClass(className);
            listClasses.add(clazz);
            System.out.println("clazz " + clazz.getName());
        }
        return listClasses;
    }

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx UtilPackage.javaxxxx

package bg.util;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

/**
 * @author bgui
 *
 */
public class UtilPackage {

    /**
     * Cette methode return toutes les class presente dans un package
     *
     * @param pClazz1
     * @return
     */
    private static List<Class> getSubClasses(final String packageName) {
        final List<Class> listClasses = new ArrayList<>();
        final String javaClassPaths[] = System.getProperty("java.class.path").split(";");
        for (final String s : javaClassPaths) {
            if (s.endsWith(".jar")) {
                //processJarFile(s, clazz1);
            } else {
                final File dirClasses = new File(s);
                final File dirPackage = new File(dirClasses, packageToPath(packageName));
                if (dirPackage.exists()) {
                    final String[] names = dirPackage.list();
                    for (final String name : names) {

                        if ((name.indexOf("$") < 0) && (name.indexOf(".class") > 0)) {
                            final String sName = name.substring(0, name.indexOf("."));
                            final String className = packageName + "." + sName;

                            try {
                                final Class clazz = UtilPackage.class.getClassLoader().loadClass(className);
                                listClasses.add(clazz);
                            } catch (final ClassNotFoundException e) {
                                System.err.println("ClassNotFound : " + e.getMessage());
                            }
                        }
                    }
                }
            }
        }
        return listClasses;
    }

    private static String packageToPath(final String packageName) {
        return packageName.replaceAll("\\.", "/");
    }

    private static File getClassPathInDirClasses(final String packageName) {
        final String javaClassPaths[] = System.getProperty("java.class.path").split(";");
        for (final String s : javaClassPaths) {
            if (s.endsWith(".jar")) {

            } else {
                final File dirClasses = new File(s);
                final File dirPackage = new File(dirClasses, packageToPath(packageName));
                if (dirPackage.exists()) {
                    return dirClasses;
                }
            }
        }
        return null;
    }

    /**
     *
     *
     * @param clazz
     *            la classe permettant de connaître le directory
     * @param packageName
     * @return
     */
    public static List<Class> getClassesFromPackage(final String packageName) {

        final File dirPath = getClassPathInDirClasses(packageName);
        if (dirPath == null) {
            return UtilJar.getClassesFromPackage(packageName);
        } else {
            final File dirPackage = new File(dirPath, packageToPath(packageName));
            return getClassesFromDir_(dirPackage, packageName);
        }

    }

    /**
     *
     * @param pDirPackage
     * @return
     */
    private static List<Class> getClassesFromDir_(final File dirPackage, final String packageName) {
        final List<Class> listClasses = new ArrayList<>();
        if (dirPackage.exists()) {
            final String[] names = dirPackage.list();
            for (final String name : names) {

                if ((name.indexOf("$") < 0) && (name.indexOf(".class") > 0)) {
                    final String sName = name.substring(0, name.indexOf("."));
                    final String className = packageName + "." + sName;
                    try {
                        final Class clazz = UtilPackage.class.getClassLoader().loadClass(className);
                        listClasses.add(clazz);
                    } catch (final ClassNotFoundException e) {
                        System.out.println("ClassNotFound :" + e.getMessage());
                    }
                }
            }
        }
        for (final File child : dirPackage.listFiles()) {
            if (child.isDirectory()) {
                final List<Class> l = getClassesFromDir_(child, packageName + "." + child.getName());
                listClasses.addAll(l);
            }
        }
        return listClasses;
    }

    public static void main(final String[] s) {

        final List<Class> list = getClassesFromPackage("bg");
        System.out.println("list result " + list.size());
        for (final Class c : list) {
            System.out.println("Result : " + c.getName());
        }

    }

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx UtilReflection.javaxxxx

package bg.util;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;

public class UtilReflection {

    /**
     * Instancie un objet avec des valeurs par defaut pour les String
     *
     * @param clazz
     * @return
     * @throws Exception
     */
    public static Object createObjet(final Class<?> clazz) throws Exception {
        return createObjet(clazz, true);
    }

    /**
     * Cree un objet avec eventuellement des valeurs par defauts pour les String
     *
     * @param clazz
     * @param populateString
     * @return
     * @throws Exception
     */
    public static Object createObjet(final Class<?> clazz, final boolean populateString) throws Exception {

        final Object o = clazz.getConstructor().newInstance();
        int i = 0;
        for (final Field f : clazz.getDeclaredFields()) {
            if (f.getType().equals(String.class)) {
                f.setAccessible(true);
                if (populateString) {
                    final String value = "AZERTY_" + i++ + "_" + f.getName();
                    f.set(o, value);
                }
            } else {

                if (f.getType().getPackage() == null) {
                } else if (f.getType().getPackage().getName().indexOf("atom") > 0) {
                    final Object oo = createObjet(f.getType(), populateString);
                    f.setAccessible(true);
                    f.set(o, oo);
                }
            }
        }
        return o;
    }

    /**
     * methode toString commede pour debuger
     *
     * @param o
     * @return
     * @throws Exception
     */
    public static String toString(final Object o) throws Exception {
        return toString(o, "");
    }

    private static String toString(final Object o, final String marge) throws Exception {

        String s = o.getClass().getName() + "\n";
        final int i = 0;
        for (final Field f : o.getClass().getDeclaredFields()) {
            if (f.getType().equals(String.class)) {
                f.setAccessible(true);
                s += marge + "   " + f.getName() + " : " + f.get(o) + "\n";

            } else {
                final boolean isCollection = Collection.class.isAssignableFrom(f.getType());
                if (isCollection) {
                    s += "  List " + f.getName() + " xxxxxxxxxxxxxxxxxxxxxxx   warning";
                }
                if (f.getType().getPackage() == null) {
                } else if (f.getType().getPackage().getName().indexOf("atom") > 0) {
                    f.setAccessible(true);
                    final Object oo = f.get(o);
                    s += "\n" + marge + toString(oo, marge + "   ");
                }
            }
        }
        return s;
    }

    /**
     * Verifie que 2 objets de classe differentes mais "similaire" , c'est a dire ayant les mêmes nom de champs , sont
     * "egaux"
     *
     * @param o1
     * @param o2
     * @return
     * @throws Exception
     */
    public static boolean equals(final Object o1, final Object o2) throws Exception {
        if (o1 == null) {
            return o2 == null;
        }
        if (o2 == null) {
            return false;
        }
        if (o2.getClass().isPrimitive()) {
            return o2 == o1;
        }
        if (isSimpleType(o1)) {
            return o1.equals(o2);
        }
        if (isSimpleType(o2)) {
            return o2.equals(o1);
        }
        if (isList(o1)) {
            if (isList(2)) {
                final List l1 = (List) o1;
                final List l2 = (List) o2;
                for (int i = 0; i < l1.size(); i++) {
                    if (i >= l2.size()) {
                        return false;
                    }
                    if (!equals(l1.get(i), l2.get(i))) {
                        return false;
                    }
                }
            } else {
                return false;
            }
        }

        for (final Field f1 : o1.getClass().getDeclaredFields()) {
            final Field f2 = getFieldFromClazz(o2.getClass(), f1.getName());
            f1.setAccessible(true);
            f2.setAccessible(true);
            if (!equals(f1.get(o1), f2.get(o2))) {
                return false;
            }

        }
        return true;
    }

    private static Field getFieldFromClazz(final Class clazz, final String pName) {
        for (final Field f : clazz.getDeclaredFields()) {
            if (f.getName().equals(pName)) {
                return f;
            }
        }
        return null;
    }

    private static boolean isList(final Object o) {

        final Class<?> clazz = o.getClass();
        return (clazz.equals(List.class)) || (clazz.equals(ArrayList.class));

    }

    private static boolean isSimpleType(final Object o) {
        final Class<?> clazz = o.getClass();
        return (clazz.equals(String.class)) || (clazz.equals(Integer.class) || (clazz.equals(Double.class))
                || (clazz.equals(Boolean.class)) || (clazz.equals(Float.class)) || (clazz.equals(Date.class)));
    }

}

 wwwwwwwwwwwwww very wwwwwwwwwww

 wwwwwwwwwwwwww simple wwwwwwwwwww

 wwwwwwwwwwwwww mapper wwwwwwwwwww


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ClassPair.javaxxxx

/**
 *
 */
package bg.very.simple.mapper;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

import javax.lang.model.element.Modifier;

import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.MethodSpec.Builder;
import com.squareup.javapoet.TypeSpec;

/**
 * @author c82bgui
 *
 */
public class ClassPair {

    private Class c1;

    private Class c2;

    private final String packageName;

    private final List<JavaFile> listJavaFile = new ArrayList<JavaFile>();

    /**
     * @param pC1
     * @param pC2
     */
    public ClassPair(final Class pC1, final Class pC2, final String packageName) {
        c1 = pC1;
        c2 = pC2;
        this.packageName = packageName;
        JavaFile javaFile;
        try {
            javaFile = getJavaFileMapperPojo();
            listJavaFile.add(javaFile);
        } catch (final Exception e) {
            System.err.println("Exception :" + e.getMessage());
            e.printStackTrace();
        }

    }

    /**
     * @return Attribut {@link #c1}
     */
    public Class getC1() {
        return c1;
    }

    /**
     * @param pC1 Valeur à affecter à l'attribut {@link #c1}
     */
    public void setC1(final Class pC1) {
        c1 = pC1;
    }

    /**
     * @return Attribut {@link #c2}
     */
    public Class getC2() {
        return c2;
    }

    /**
     * @param pC2 Valeur à affecter à l'attribut {@link #c2}
     */
    public void setC2(final Class pC2) {
        c2 = pC2;
    }

    /**
     * @return
     */
    public List<JavaFile> getListJavaFile() {

        return listJavaFile;
    }

    public JavaFile getJavaFileMapperPojo() throws Exception {

        final MethodSpec.Builder methodBuilder1 = getMethodMap(c1, c2);
        final MethodSpec.Builder methodBuilder2 = getMethodMap(c2, c1);

        final TypeSpec.Builder customClassMapperBuilder = TypeSpec.classBuilder(getClassMapperName())
                .addModifiers(Modifier.PUBLIC);

        customClassMapperBuilder.addMethod(methodBuilder1.build());
        customClassMapperBuilder.addMethod(methodBuilder2.build());

        final TypeSpec customClassMapper = customClassMapperBuilder.build();
        final JavaFile javaFile = JavaFile.builder(packageName, customClassMapper).indent("    ").build();

        return javaFile;
    }

    /**
     * @param pC1
     * @param pC2
     * @return
     * @throws SecurityException
     * @throws NoSuchFieldException
     */
    private static Builder getMethodMap(final Class pC1, final Class pC2)
            throws NoSuchFieldException, SecurityException {
        final MethodSpec.Builder methodBuilder1 = MethodSpec.methodBuilder("to" + pC1.getSimpleName())
                .addParameter(pC2, "o").addModifiers(Modifier.PUBLIC).returns(pC1);
        methodBuilder1.addStatement(" $T r = new $T()", pC1, pC1);

        for (final Field field1 : pC1.getDeclaredFields()) {
            Field field2;
            try {
                field2 = pC2.getDeclaredField(field1.getName());
            } catch (final NoSuchFieldException e) {
                field2 = null;
            }
            if (field2 == null) {
            } else if (field1.getType().equals(field2.getType())) {
                final String getter = getGetter(field1);
                if (isMethodExists(getter, pC1)) {
                    methodBuilder1.addStatement("  r." + getSetter(field1) + "(o." + getter + ") ");
                } else {
                    final String getter2 = getGetter2(field1);
                    if (isMethodExists(getter2, pC1)) {
                        methodBuilder1.addStatement("  r." + getSetter(field1) + "(o." + getter2 + ") ");
                    }
                }
            } else {
                if (field1.getType().isPrimitive()) {

                } else {
                    methodBuilder1.addStatement("  r." + getSetter(field1) + "(null)");
                }

            }
        }
        methodBuilder1.addStatement("return r ", pC1);
        return methodBuilder1;
    }

    private static String getGetter2(final Field field) {
        final String name = capitalizeFirstLetter(field.getName());
        final String methodName = "is" + name + "()";
        return methodName;
    }

    /**
     * @param pField1
     * @return
     */
    private static String getGetter(final Field field) {
        final String name = capitalizeFirstLetter(field.getName());
        final String methodName = "get" + name + "()";
        return methodName;
    }

    private static boolean isMethodExists(String name, final Class clazz) {
        if (name == null) {
            return false;
        }
        final int i = name.indexOf("(");
        if (i > 0) {
            name = name.substring(0, i);

        }
        for (final Method m : clazz.getMethods()) {
            if (m.getName().equals(name)) {
                return true;
            }
        }
        return false;
    }

    private static String getSetter(final Field field) {
        final String name = capitalizeFirstLetter(field.getName());
        return "set" + name;
    }

    /**
     * @param pName
     * @return
     */
    private static String capitalizeFirstLetter(final String str) {
        final String s = str.substring(0, 1).toUpperCase() + str.substring(1);
        return s;
    }

    /**
     * @param pField1
     * @param pC2
     * @return
     * @throws SecurityException
     * @throws NoSuchFieldException
     */
    private Builder getMethodBuilder1(final Field field1, final Class pC2)
            throws NoSuchFieldException, SecurityException {

        final Field field2 = c2.getDeclaredField(field1.getName());
        final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("to" + field1.getName())
                .addParameter(field2.getType(), "s").addModifiers(Modifier.PUBLIC).returns(field1.getType());
        if (isSimpleNativeField(field1.getType()) && isSimpleNativeField(field2.getType())) {

        }
        return methodBuilder;
    }

    /**
     * @param pType
     * @return
     */
    private boolean isSimpleNativeField(final Class<?> type) {
        if (type.isPrimitive()) {
            return true;
        }
        if (type.equals(String.class)) {
            return true;
        }
        return false;
    }

    /**
     * @return
     */
    private String getClassMapperName() {

        return "Mapper_" + c1.getSimpleName();
    }

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx GeneratorVerySimpleMapper.javaxxxx

/**
 *
 */
package bg.very.simple.mapper;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import com.squareup.javapoet.JavaFile;

import bg.util.UtilPackage;

/**
 * @author c82bgui
 *
 */
public class GeneratorVerySimpleMapper {

    List<Class> listClassNonTraitees_1 = new ArrayList<Class>();

    List<Class> listClassNonTraitees_2 = new ArrayList<Class>();

    private final JavaPoetWriter javaPoetWritter;

    private String packageGenerated = "bg";

    /**
     * @param pDirOutput
     * @param pPackage1
     * @param pPackage2
     * @param pString
     */
    public GeneratorVerySimpleMapper(final File pDirOutput, final String packageName1, final String packageName2,
            final String packageGenerated) {
        this(pDirOutput, UtilPackage.getClassesFromPackage(packageName1),
                UtilPackage.getClassesFromPackage(packageName2), packageGenerated);
    }

    /**
     * @param pDirOutput
     * @param pClassesFromPackage
     * @param pClassesFromPackage2
     * @param pPackageGenerated
     */
    public GeneratorVerySimpleMapper(final File dirOutput, final List<Class> listClass1, final List<Class> listClass2,
            final String pPackageGenerated) {
        System.err.println("listClass1 " + listClass1.size());
        System.err.println("listClass2 " + listClass2.size());
        javaPoetWritter = new JavaPoetWriter(dirOutput);
        packageGenerated = pPackageGenerated;
        processListSubClass(listClass1, listClass2);
        processXml();

    }

    private void processXml() {

        final MappingConfiguration mappingConfiguration = new MappingConfiguration(listPaires, listClassNonTraitees_1,
                listClassNonTraitees_2);
        MappingConfigurationHelper.printConfiguration(mappingConfiguration);
    }

    /**
     * @param pListSubClass1
     * @param pListSubClass2
     */
    private List<ClassPair> listPaires;

    private void processListSubClass(final List<Class> listSubClass1, final List<Class> listSubClasses2) {
        listPaires = initClassPair(listSubClass1, listSubClasses2);
        for (final ClassPair cp : listPaires) {
            processPair(cp);
        }

        System.err.println("\nNb de mappage " + listPaires.size());
        System.err.println("Write to  " + javaPoetWritter.getDirOutput().getAbsolutePath());
    }

    /**
     * @param pCp
     */
    private void processPair(final ClassPair classPair) {

        for (final JavaFile javafile : classPair.getListJavaFile()) {
            javaPoetWritter.write(javafile);
        }

    }

    private List<ClassPair> initClassPair(final List<Class> listSubClass1, final List<Class> listSubClasses2) {
        final List<ClassPair> listClassPairs = new ArrayList<ClassPair>();
        for (final Class c1 : listSubClass1) {
            final Class c2 = getClassFromSimpleList(c1, listSubClasses2);
            if (c1.getSimpleName().equals("package-info")) {
            } else if (c2 == null) {
                listClassNonTraitees_1.add(c1);
                System.err.println("No class pair for c1: " + c1.getName() + "   " + c1.getName());
            } else if (c1.getName().equals(c2.getName())) {
                System.err.println("No class pair for c1: " + c1.getName() + " equals   " + c2.getName());
            } else {
                final ClassPair classPair = new ClassPair(c1, c2, packageGenerated);
                listClassPairs.add(classPair);
            }
        }
        for (final Class c2 : listSubClasses2) {
            if (!isPaired_2(c2, listClassPairs)) {
                listClassNonTraitees_2.add(c2);
            }
        }
        return listClassPairs;
    }

    private boolean isPaired_2(final Class pC2, final List<ClassPair> pListClassPairs) {
        for (final ClassPair cp : pListClassPairs) {
            if (cp.getC2().equals(pC2)) {
                return true;
            }
        }
        return false;
    }

    /**
     * @param pC1
     * @param pListSubClasses2
     * @return
     */
    private Class getClassFromSimpleList(final Class c1, final List<Class> listSubClasses2) {
        final Class clazz = PropertiesClasses.getClassesPair(c1.getName());
        if (clazz != null) {
            return clazz;
        }
        final List<Class> lClass = getListClassBySimpleName(c1.getSimpleName(), listSubClasses2);
        if (lClass.size() == 0) {
            System.err.println("No Class for : " + c1.getSimpleName());
            return null;
        } else if (lClass.size() == 1) {
            return lClass.get(0);
        } else {
            return bestChoiceFromList(c1, lClass);
        }

    }

    /**
     * @param pSimpleName
     * @param pListSubClasses2
     * @return
     */
    private List<Class> getListClassBySimpleName(final String pSimpleName, final List<Class> pListSubClasses2) {
        final List<Class> list = new ArrayList<>();
        for (final Class c : pListSubClasses2) {
            if (c.getSimpleName().equals(pSimpleName)) {
                list.add(c);
            }
        }
        return list;
    }

    /**
     * @param pC1
     * @param pLClass
     * @return
     */
    private Class bestChoiceFromList(final Class pC1, final List<Class> listClass) {
        // Les classes ont toutes le meme simpleNom .
        // Quel critère ? Le nombre de champs ? le nom de package ?
        // Les noms des champs ?
        // TODO Faite une class UtilCompareClass avec les methodes qui vont bien
        return listClass.get(0);
    }

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx JavaPoetWriter.javaxxxx

package bg.very.simple.mapper;

import java.io.File;
import java.io.IOException;

import com.squareup.javapoet.JavaFile;

/**
 * @author c82bgui
 *
 */
public class JavaPoetWriter {

    private final File dirOutput;

    public JavaPoetWriter(final File dir) {
        dirOutput = dir;
        dir.mkdirs();
    }

    /**
     * @param pJavafile
     */
    public void write(final JavaFile javafile) {
        try {

            javafile.writeTo(dirOutput);

        } catch (final IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public File getDirOutput() {
        return dirOutput;
    }

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx MainMapperTest.javaxxxx

/**
 *
 */
package bg.very.simple.mapper;

/**
 * @author c82bgui
 *
 */

import java.io.File;

/**
 * @author c82bgui
 *
 */
public class MainMapperTest {

    /**
     * @author bgui
     *
     *
     *
     *         private String packageSourcePath = "D:\\";
     *
     *         /**
     * @param args
     */
    public static void main(final String[] args) throws Exception {
        System.err.println("MainMapperTest Start");
        final File dirOutput = new File("GENERATED3");
        final String package1 = "fr.msa.atom.sante.prestationsennature.facturepn";
        final String package2 = "fr.msa.si.sante.prestationsennature.facturepn";
        final GeneratorVerySimpleMapper gmpa = new GeneratorVerySimpleMapper(dirOutput, package1, package2, "bg.test");

    }

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx MappingConfiguration.javaxxxx

package bg.very.simple.mapper;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;

@XmlRootElement
@XmlType(name = "mapping")
public class MappingConfiguration {

    private List<ClassPair> paires = new ArrayList<>();

    private List<Class> listClassNonTraitees_1 = new ArrayList<>();

    private List<Class> listClassNonTraitees_2 = new ArrayList<>();

    /**
     *
     */
    public MappingConfiguration() {
        super();
    }

    public MappingConfiguration(final List<ClassPair> pListPaires, final List<Class> pListClassNonTraitees_1,
            final List<Class> pListClassNonTraitees_2) {
        paires = pListPaires;
        listClassNonTraitees_1 = pListClassNonTraitees_1;
        listClassNonTraitees_2 = pListClassNonTraitees_2;
    }

    /**
     * @return Attribut {@link #paires}
     */
    public List<ClassPair> getPaires() {
        return paires;
    }

    /**
     * @param pPaires Valeur à affecter à l'attribut {@link #paires}
     */
    public void setPaires(final List<ClassPair> pPaires) {
        paires = pPaires;
    }

    /**
     * @return Attribut {@link #listClassNonTraitees_1}
     */
    public List<Class> getListClassNonTraitees_1() {
        return listClassNonTraitees_1;
    }

    /**
     * @param pListClassNonTraitees_1 Valeur à affecter à l'attribut {@link #listClassNonTraitees_1}
     */
    public void setListClassNonTraitees_1(final List<Class> pListClassNonTraitees_1) {
        listClassNonTraitees_1 = pListClassNonTraitees_1;
    }

    /**
     * @return Attribut {@link #listClassNonTraitees_2}
     */
    public List<Class> getListClassNonTraitees_2() {
        return listClassNonTraitees_2;
    }

    /**
     * @param pListClassNonTraitees_2 Valeur à affecter à l'attribut {@link #listClassNonTraitees_2}
     */
    public void setListClassNonTraitees_2(final List<Class> pListClassNonTraitees_2) {
        listClassNonTraitees_2 = pListClassNonTraitees_2;
    }

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx MappingConfigurationHelper.javaxxxx

package bg.very.simple.mapper;

import java.io.File;
import java.io.FileWriter;
import java.io.StringWriter;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.Unmarshaller;

public class MappingConfigurationHelper {

    public static String toStringXml(final MappingConfiguration mappingConfiguration) throws Exception {
        final JAXBContext jc = JAXBContext.newInstance(MappingConfiguration.class);
        final javax.xml.bind.Marshaller marshaller = jc.createMarshaller();
        marshaller.setProperty(javax.xml.bind.Marshaller.JAXB_FORMATTED_OUTPUT, true);
        final StringWriter sw = new StringWriter();
        marshaller.marshal(mappingConfiguration, sw);
        final String xmlContent = sw.toString();
        return xmlContent;
    }

    public static void printConfiguration(final MappingConfiguration mappingConfiguration) {
        try {
            final String s = toStringXml(mappingConfiguration);
            System.err.println("xml:" + s);
            final File f = new File("CONFIGURATION.xml");
            final FileWriter fw = new FileWriter(f);
            fw.write(s);
            fw.close();
            System.err.println("Print to :" + f.getName() + " exists: " + f.exists());
        } catch (final Exception e) {
            e.printStackTrace();
        }
    }

    public static MappingConfiguration readConfiguration(final File file) {
        try {
            final JAXBContext jc = JAXBContext.newInstance(MappingConfiguration.class);
            final Unmarshaller unmarshaller = jc.createUnmarshaller();
            unmarshaller.setProperty(javax.xml.bind.Marshaller.JAXB_FORMATTED_OUTPUT, true);
            final Object o = unmarshaller.unmarshal(file);
            return (MappingConfiguration) o;
        } catch (final Exception e) {
            e.printStackTrace();
        }
        return null;
    }

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx PropertiesClasses.javaxxxx

/**
 *
 */
package bg.very.simple.mapper;

import java.util.Properties;

/**
 * @author c82bgui
 *
 */
public class PropertiesClasses {

    public static Properties pClasses = new Properties();
    static {
        pClasses.setProperty("fr.msa.atom.sante.prestationsennature.facturepn.objets.individusanteatom.v1.Assureur",
                "fr.atom.referentiel.assurance.domain.assureur.Assureur");
        pClasses.setProperty(
                "fr.msa.atom.sante.prestationsennature.facturepn.objets.individusanteatom.v1.SoinsPlanifies",
                "fr.atom.sante.relationsassure.contratassurance.domain.contratassurance.SoinsPlanifies");
    }

    static Class getClassesPair(final String className) {
        try {
            final String name = pClasses.getProperty(className);
            if (name == null) {
                return null;
            }
            return PropertiesClasses.class.getClassLoader().loadClass(name);
        } catch (final ClassNotFoundException e) {
            return null;
        }

    }
}

 wwwwwwwwwwwwww bm1 wwwwwwwwwww

 wwwwwwwwwwwwww generation wwwwwwwwwww

 wwwwwwwwwwwwww code wwwwwwwwwww

 wwwwwwwwwwwwww old wwwwwwwwwww

 wwwwwwwwwwwwww poubelle wwwwwwwwwww


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx JavaPoetWriter.javaxxxx

/**
 *
 */
package bm1.generation.code.old.poubelle;

import java.io.File;
import java.io.IOException;

import com.squareup.javapoet.JavaFile;

/**
 * @author c82bgui
 *
 */
public class JavaPoetWriter {

    File dir = new File("outPut");

    JavaPoetWriter() {
        dir.mkdirs();
    }

    /**
     * @param pJavafile
     */
    public void write(final JavaFile javafile) {
        try {

            javafile.writeTo(dir);
        } catch (final IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx MainGenerateAbstrctMapper.javaxxxx

/**
 *
 */
package bm1.generation.code.old.poubelle;

/**
 * @author c82bgui
 *
 */
public class MainGenerateAbstrctMapper {

    String packageSourcePath = "D:\\platformsg2_R_64\\workspace\\bm1atom-tarif\\bm1atom-tarif-ws\\target\\generated-sources\\cxf";

    /**
     * @param args
     */
    public static void main(final String[] args) throws Exception {

        System.err.println("start");
        Thread.sleep(100);
        final Class clazz1 = getClassByName(
                "fr.atom.sante.relationsassure.contratassurance.domain.contratassurance.SoinsPlanifies");
        final Class clazz2 = getClassByName(
                "fr.msa.atom.sante.prestationsennature.facturepn.objets.individusanteatom.v1.SoinsPlanifies");
        System.err.println("Start ---------------- " + clazz1);
        System.err.println("Start ---------------- " + clazz2);
        //        final GeneratorMapperAbstractClass gmpa = new GeneratorMapperAbstractClass(clazz1, clazz2);
    }

    private static Class getClassByName(final String s) throws ClassNotFoundException {
        return MainGenerateAbstrctMapper.class.getClassLoader().loadClass(s);
    }

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx UtilPoet.javaxxxx

/**
 *
 */
package bm1.generation.code.old.poubelle;

import javax.lang.model.element.Modifier;

import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;

/**
 * @author c82bgui
 *
 */
public class UtilPoet {

    /**
     * @param pC1
     * @param pC2
     */
    public static JavaFile generateInterfaceMapper(final Class c1, final Class c2) {
        final String nameMapper = c1.getSimpleName() + "Mapper";
        final TypeSpec interfaceMapper = TypeSpec.interfaceBuilder(nameMapper).addModifiers(Modifier.PUBLIC)
                .addMethod(MethodSpec.methodBuilder("map").addModifiers(Modifier.ABSTRACT, Modifier.PUBLIC).returns(c2)
                        .addParameter(c1, "c1").build())
                .addMethod(MethodSpec.methodBuilder("map").addModifiers(Modifier.ABSTRACT, Modifier.PUBLIC).returns(c1)
                        .addParameter(c2, "c2").build())
                .build();

        final JavaFile javaFile = JavaFile.builder("com.bg.generted", interfaceMapper).indent("    ").build();
        return javaFile;
    }

}


 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx UtilReflection.javaxxxx

/**
 *
 */
package bm1.generation.code.old.poubelle;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

/**
 * @author c82bgui
 *
 */
public class UtilReflection {

    public static void main(final String[] a) {
        final List<Class> list = getSubClasses(UtilReflection.class);
        System.out.println("list " + list.size());
    }

    /**
     * @param pClazz1
     * @return
     */
    public static List<Class> getSubClasses(final Class clazz1) {
        final List<Class> listClasses = new ArrayList<>();
        final Package package1 = clazz1.getPackage();
        System.err.println("getSubClasses " + clazz1);
        final String packageName = package1.getName();
        System.err.println("getSubClasses " + package1.getName());

        // System.err.println("java.class.path : " + System.getProperty("java.class.path"));
        final String javaClassPaths[] = System.getProperty("java.class.path").split(";");
        for (final String s : javaClassPaths) {
            if (s.endsWith(".jar")) {
                // processJarFile(s, clazz1);
            } else {
                final File dirClasses = new File(s);
                final File dirPackage = new File(dirClasses, getPackagePath(clazz1));
                if (dirPackage.exists()) {
                    final String[] names = dirPackage.list();
                    for (final String name : names) {

                        if ((name.indexOf("$") < 0) && (name.indexOf(".class") > 0)) {
                            final String sName = name.substring(0, name.indexOf("."));
                            final String className = clazz1.getPackage().getName() + "." + sName;

                            try {
                                final Class clazz = UtilReflection.class.getClassLoader().loadClass(className);
                                listClasses.add(clazz);
                            } catch (final ClassNotFoundException e) {
                                System.out.println("ClassNotFound :" + e.getMessage());
                            }
                        }
                    }

                }

            }
        }
        return listClasses;
    }

    /**
     * @param pJarFile
     */
    private static void processJarFile(final String s, final Class clazz) {
        try {
            final JarFile jarFile = new JarFile(s);
            final JarEntry jarEntryClazz = jarFile.getJarEntry(clazz.getName().replaceAll(".", "/") + ".class");
            if (jarEntryClazz != null) {
                System.err.println("BINGO BINGO " + jarFile.getName());
            }
            final Enumeration<JarEntry> entries = jarFile.entries(); //gives ALL entries in jar
            while (entries.hasMoreElements()) {
                final String name = entries.nextElement().getName();
                final String packageName = getPackagePath(clazz);
                if (name.startsWith(packageName)) { //filter according to the path
                    System.err.println("YYYYYYYYYYYYYYYYES :" + name + "   " + jarFile.getName());
                }
            }
            jarFile.close();
        } catch (final IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    }

    private static String getPackagePath(final Class clazz) {
        final String packageName = clazz.getPackage().getName().replaceAll("\\.", "/");;
        return packageName;
    }

}

0 checker  ClassPair.java
1 checker  GeneratorCheckerStringForgottenClass.java
2 checker  GeneratorCheckerStringForgottenMethod.java
3 checker  MainGeneratorChecker.java
4 bg  ClassFinder.java
5 bg  ClassPair.java
6 bg  JavaPoetWriter.java
7 justification  MainHelperJustification.java
8 bg  MainConcatene.java
9 mapper  ClassMapperGenerator.java
10 mapper  ClassPair.java
11 mapper  GeneratorMapperMethod.java
12 helper  MainListClassFromPackage.java
13 mapper  MainGeneratorMapper.java
14 bg  PropertiesClasses.java
15 util  MainGetClassesFromPackage.java
16 util  UtilJar.java
17 util  UtilPackage.java
18 util  UtilReflection.java
19 mapper  ClassPair.java
20 mapper  GeneratorVerySimpleMapper.java
21 mapper  JavaPoetWriter.java
22 mapper  MainMapperTest.java
23 mapper  MappingConfiguration.java
24 mapper  MappingConfigurationHelper.java
25 mapper  PropertiesClasses.java
26 poubelle  JavaPoetWriter.java
27 poubelle  MainGenerateAbstrctMapper.java
28 poubelle  UtilPoet.java
29 poubelle  UtilReflection.java

Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF8

