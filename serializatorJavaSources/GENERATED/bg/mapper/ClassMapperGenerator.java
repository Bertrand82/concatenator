package bg.mapper;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import javax.lang.model.element.Modifier;

import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;

import atom.msa.fr.sante.prestationsennature.facturepn.services.v1.RapportFactory;
import atom.msa.fr.sante.prestationsennature.facturepn.services.v1.RapportManager;
import bg.very.simple.mapper.JavaPoetWriter;

public class ClassMapperGenerator {

    private final String packageName = "bg.mapper";

    private final List<ClassPair> listPairInitiale;

    private final List<GeneratorMapperMethod> listGeneratorMapperMethod = new ArrayList<GeneratorMapperMethod>();

    private final File dirOutput = new File("GENERATED_COMPARATOR_MAPPER");

    private final JavaPoetWriter javaPoetWritter = new JavaPoetWriter(dirOutput);

    public ClassMapperGenerator(final List<ClassPair> pListPair) {
        listPairInitiale = pListPair;
        dirOutput.mkdirs();
        for (final ClassPair cp : listPairInitiale) {
            processClass(cp);
        }

        javaPoetWritter.write(getJavaFileMapper());

        System.err.println("Done  dirOutput.exists :" + dirOutput.exists());
    }

    private void processClass(final ClassPair pCp) {
    }

    public JavaFile getJavaFileMapper() {

        final TypeSpec.Builder classBuilder = TypeSpec.classBuilder(getClassMapperName()).addModifiers(Modifier.PUBLIC);

        final MethodSpec constructor0 = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC)
                .addStatement("this($T.getRapportManager())", RapportFactory.class).build();

        final MethodSpec constructor1 = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC)
                .addParameter(RapportManager.class, "rapportManager")
                .addStatement("this.rapportManager = rapportManager", RapportFactory.class).build();
        String comment = "Cette Class permet de s'assurer que lors des opérations de mappage, certains champs que l'on n'a pas pu mapper de String vers des enum ont bien recupéré leurs valeurs originelles à la fin du traitement \n";
        comment += " Les classes vérifiées sont les suivantes : \n";
        for (final ClassPair cp : listPairInitiale) {
            comment += " --------- ";
            comment += "1 : \t" + cp.c1.getName() + "\n";
            comment += "2: \t" + cp.c2.getName() + "\n";
        }
        classBuilder.addJavadoc(comment);
        classBuilder.addMethod(constructor0);
        classBuilder.addMethod(constructor1);
        classBuilder.addField(FieldSpec.builder(RapportManager.class, "rapportManager", Modifier.PRIVATE).build());

        for (final GeneratorMapperMethod cg : listGeneratorMapperMethod) {
            classBuilder.addMethod(cg.getMethodMapper1());
            classBuilder.addMethod(cg.getMethodMapper2());
        }

        final TypeSpec customClassMapper = classBuilder.build();
        final JavaFile.Builder javaFileBuilder = JavaFile.builder(packageName, customClassMapper).indent("    ");

        javaFileBuilder.addFileComment("Generated by " + this.getClass().getName());
        final JavaFile javaFile = javaFileBuilder.build();
        return javaFile;
    }

    private String getClassMapperName() {
        return null;
    }

}



/**
 *
 */
