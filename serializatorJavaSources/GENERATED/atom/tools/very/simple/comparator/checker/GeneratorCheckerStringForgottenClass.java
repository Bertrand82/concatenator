package atom.tools.very.simple.comparator.checker;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import javax.lang.model.element.Modifier;

import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;

import atom.msa.fr.sante.prestationsennature.facturepn.services.v1.RapportFactory;
import atom.msa.fr.sante.prestationsennature.facturepn.services.v1.RapportManager;
import bg.very.simple.mapper.JavaPoetWriter;

public class GeneratorCheckerStringForgottenClass {

    private static String packageName = "atom.generated.comparator";

    List<GeneratorCheckerStringForgottenMethod> listComparatorGenerator = new ArrayList<>();

    private final JavaPoetWriter javaPoetWritter;

    private final File dirOutput = new File("GENERATED_COMPARATOR");

    private final ClassPair classPair;

    public GeneratorCheckerStringForgottenClass(final Class<?> clazzOut, final Class<?> clazzIn)
            throws ClassNotFoundException {
        super();
        dirOutput.mkdirs();
        final ClassPair cp = new ClassPair(clazzIn, clazzOut);
        classPair = cp;
        processClass(cp);

        javaPoetWritter = new JavaPoetWriter(dirOutput);
        javaPoetWritter.write(getJavaFileChecker());
        System.err.println("Done  dirOutput.exists :" + dirOutput.exists());
    }

    private void processClass(final ClassPair cPair) throws ClassNotFoundException {
        final GeneratorCheckerStringForgottenMethod cg = new GeneratorCheckerStringForgottenMethod(cPair);
        listComparatorGenerator.add(cg);
        for (final ClassPair cp : cg.getListClassPair()) {
            if (!cp.isAlreadyProcessed()) {
                processClass(cp);
            }
        }

    }

    /**
     * @param pCp
     */
    private void processGeneratorJavaFile() {
        javaPoetWritter.write(getJavaFileChecker());

    }

    public JavaFile getJavaFileChecker() {

        final TypeSpec.Builder classBuilder = TypeSpec.classBuilder(getClassMapperName()).addModifiers(Modifier.PUBLIC);

        final MethodSpec constructor0 = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC)
                .addStatement("this($T.getRapportManager())", RapportFactory.class).build();

        final MethodSpec constructor1 = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC)
                .addParameter(RapportManager.class, "rapportManager")
                .addStatement("this.rapportManager = rapportManager", RapportFactory.class).build();
        String comment = "Cette Class permet de s'assurer que lors des opérations de mappage, certains champs que l'on n'a pas pu mapper de String vers des enum ont bien recupéré leurs valeurs originelles à la fin du traitement \n";
        comment += " Les classes vérifiées sont les suivantes : \n";
        comment += "In : \t" + classPair.classIn.getName() + "\n";
        comment += "Out: \t" + classPair.classOut.getName() + "\n";
        classBuilder.addJavadoc(comment);

        classBuilder.addMethod(constructor0);
        classBuilder.addMethod(constructor1);
        classBuilder.addField(FieldSpec.builder(RapportManager.class, "rapportManager", Modifier.PRIVATE).build());

        for (final GeneratorCheckerStringForgottenMethod cg : listComparatorGenerator) {
            classBuilder.addMethod(cg.getMethodCompare());
        }

        final TypeSpec customClassMapper = classBuilder.build();
        final JavaFile.Builder javaFileBuilder = JavaFile.builder(packageName, customClassMapper).indent("    ");

        javaFileBuilder.addFileComment("Generated by " + this.getClass().getName());
        final JavaFile javaFile = javaFileBuilder.build();
        return javaFile;
    }

    private String getClassMapperName() {
        return "CheckerStringForgotten";
    }

}



